#!/bin/bash

FN=$1
PK=${2:-com.a}
DATA=`basename -s .java ${FN}`
FNJ=${DATA}DbProvider.java
FNT=${DATA}.tmp

cat ${FN}|grep '^\s*private\s\+\w\+\s\+\w\+;' | sed -e's/^\s*private\s\+\(\w\+\)\s\+\(\w\+\);/\1 \2/'>$FNT

echo "//auto generated by OK tool">${FNJ}
echo "package ${PK}.db;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import java.util.ArrayList;
import java.util.Date;

import ${PK}.data.${DATA};

public class ${DATA}DbProvider {
    private static final String TABLE=\"${DATA}\";
    private static final String TAG = \"${DATA}DbProvider\";

    // Variable to hold the database instance
    protected SQLiteDatabase db;
    // Database open/upgrade helper
    private SQLiteOpenHelper dbHelper;

    public ${DATA}DbProvider(SQLiteOpenHelper dbHelper) {
        this.dbHelper = dbHelper;
    }

    public SQLiteDatabase open() throws SQLException { 
        db = dbHelper.getWritableDatabase();
        return db;
    }

    public void close() {
        db.close();
    }

    // Called when no database exists in disk and the helper class needs to create a new one..
    public static void onCreate(SQLiteDatabase db) {
        db.execSQL(\"CREATE TABLE \" +TABLE+ \"( '_id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\"+">>$FNJ
cat ${FNT}|grep -v " _id" |sed -e 's/\(\w\+\) \(\w\+\)/            "\2 \1/'\
        |sed -e's/long/INTEGER/' -e's/String/TEXT/' -e's/Date/INTEGER/' -e's/int/INTEGER/'\
	|sed -e '$ ! s/$/," +/'|sed -e '$ s/$/" +/'>>$FNJ
echo "            \");\");
    }

    // Called when there is a database version mismatch meaning that the version
    // of the database on disk needs to be upgraded to the current version.
    public static void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Log the version upgrade.
        Log.w(TAG, \"Upgrading from version \" +
                    oldVersion + \" to \" +
                    newVersion + \", which will destroy all old data\");
        // Upgrade the existing database to conform to the new version. Multiple.
        // previous versions can be handled by comparing _oldVersion and _newVersion
        // values.
        // The simplest case is to drop the old table and create a new one.
        // db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE + \";\"); // Create a new one.
        // onCreate(db);
    }
    //ColumnIndexes">>${FNJ}
cat ${FNT}|sed -e 's/\(\w\+\) \(\w\+\)/    private int \2ColumnIndex;/' >>$FNJ

echo "
    String[] Columns=new String[]{">>${FNJ}
cat ${FNT}|sed -e 's/\(\w\+\) \(\w\+\)/        "\2"/'|sed -e '$ ! s/$/,/' >>$FNJ
echo "    };

    private void Cursor2ColumnIndexes(Cursor cursor){">>${FNJ}
cat ${FNT}|sed -e 's/\(\w\+\) \(\w\+\)/        \2ColumnIndex=cursor.getColumnIndex("\2");/' >>$FNJ
echo "    }

    private ContentValues Data2CV (${DATA} data){
        ContentValues cv= new ContentValues();" >>${FNJ}
cat ${FNT}|sed -e 's/\(\w\+\) \(\w\+\)/        cv.put("\2", data.get\2()\1);/' \
        |sed -e's/get\([a-z]\)/get\U\1/' -e's/get_id/getId/' \
        |sed -e's/()long/()/' -e's/()String/()/' -e's/()Date/().getTime()/' -e's/()int/()/'>>$FNJ
echo "        return cv;
    }

    private ${DATA} Cursor2Data(Cursor cursor){
        //Cursor2ColumnIndexes(cursor);
        return new ${DATA}(">>${FNJ}
cat ${FNT}|sed -e 's/\(\w\+\) \(\w\+\)/            cursor.get\1(\2ColumnIndex)/' \
        |sed -e's/\(cursor.get\)\(\w\)/\1\U\2/'\
        |sed -e's/cursor.getDate\((\w\+)\)/new Date(cursor.getLong\1)/'\
        |sed -e '$ ! s/$/,/' >>$FNJ
echo "        );
    }

    public long Add(${DATA} data){
        ContentValues cv=Data2CV(data);
        long id=db.insert(TABLE, null, cv);
        data.setId(id);
        return id;
    }

    public long Update(${DATA} data){
        String where=\"_id=\"+data.getId();
        ContentValues cv=Data2CV(data);
        long rows=db.update(TABLE, cv, where, null);
        return rows;
    }

    public long Remove(${DATA} data){
        String where=\"_id=\"+data.getId();
        long rows=db.delete(TABLE, where, null);
        return rows;
    }

    public long Remove(long id){
        String where=\"_id=\"+id;
        long rows=db.delete(TABLE, where, null);
        return rows;
    }

    public long RemoveAll(){
        long rows=db.delete(TABLE, null, null);
        return rows;
    }

    public ${DATA} Get(long id){
        String where=\"_id=\"+id;
        Cursor cursor=db.query(TABLE, Columns, where, null,null,null,null);
        if(cursor != null){
                cursor.moveToFirst();
                Cursor2ColumnIndexes(cursor);
                ${DATA} data=Cursor2Data(cursor);
                return data;
        }
        return null;
    }

    public ArrayList<${DATA}> Get(String where){
        Cursor cursor=db.query(TABLE, Columns, where, null,null,null,null);
        ArrayList<${DATA}> dataArray=new ArrayList<${DATA}>();
        if(cursor != null){
                cursor.moveToFirst();
                Cursor2ColumnIndexes(cursor);
                do {
                        ${DATA} data=Cursor2Data(cursor);
                        dataArray.add(data);
                } while (cursor.moveToNext());
        }
        return dataArray;
    }

    public ArrayList<${DATA}> GetAll(){
        Cursor cursor=db.query(TABLE, Columns, null, null,null,null,null);
        ArrayList<${DATA}> dataArray=new ArrayList<${DATA}>();
        if(cursor != null){
                cursor.moveToFirst();
                Cursor2ColumnIndexes(cursor);
                do {
                        ${DATA} data=Cursor2Data(cursor);
                        dataArray.add(data);
                } while (cursor.moveToNext());
        }
        return dataArray;
    }
}">>${FNJ}

